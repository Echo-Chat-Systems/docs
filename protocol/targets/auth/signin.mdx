---
title: "signin"
description: "Step-by-step process for secure Ed25519-based user authentication."
---

# `signin`

The signin process is a multi-step authentication mechanism using Ed25519 public/private keypairs. It is **passwordless**, secure, and resistant to phishing.

## Overview

The client proves ownership of a private key through a signed challenge-response protocol. The server does not store any passwords or long-term secrets for clients.

---

## Signin Flow

### 1. `signin-start`

The client initiates the authentication flow by sending its **Ed25519 public key**.

<CodeGroup>
```json Example
{
    "target": "auth",
    "data": {
        "action": "signin-start",
        "params": {
            "sk": "",
            "ek": ""
        }
    }
}
```
```json Params Schema
{
    "title": "Signin Start Params Schema",
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "/static/schemas/comms/auth/signin/signin-start.json",
    "type": "object",
    "required": [
        "sk", "ek"
    ],
    "properties": {
        "sk": {
            "type": "string",
            "format": "base64"
        },
        "ek": {
            "type": "string",
            "format": "base64"
       }
    }
}
```
</CodeGroup>

#### Parameters

<ParamField body="sk" type="string" required>
    User [Public Signing Key](/protocol/definitions/crypto/keys.mdx#signing-key).
</ParamField>
<ParamField body="ek" type="string" required>
    User [Public Encryption Key](/protocol/definitions/crypto/keys.mdx#encryption-key).
</ParamField>


### 2. `signin-challenge` *(Server → Client)*

The server responds with a unique challenge string to be signed.

<CodeGroup>
```json Example
{
    "target": "auth",
    "data": {
        "action": "signin-challenge",
        "params": {
            "sign-challenge": "",
            "encrypt-challenge": ""
        }
    }
}
```
```json Params Schema
{
    "title": "Signin Challenge Params Schema",
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "/static/schemas/comms/auth/signin/signin-challenge.json",
    "type": "object",
    "required": [
        "sign-challenge",
        "encrypt-challenge"
    ],
    "properties": {
        "sign-challenge": {
            "type": "string",
            "minLength": 128,
            "maxLength": 128
        },
        "encrypt-challenge": {
            "type": "string",
            "format": "base64"
        }
    }
}
```
</CodeGroup>

#### Parameters

<ParamField body="sign-challenge" type="string" required>
    Random string the user must sign.
</ParamField>
<ParamField body="encrypt-challenge" type="string" required>
    Random string encrypted using the users public `ek`.
</ParamField>


### 3. `signin-response`

The client signs the challenge using its **private key** and returns the signature.

<CodeGroup>
```json Example
{
    "target": "auth",
    "data": {
        "action": "signin-response",
        "params": {
            "signature": "",
            "decrypted": ""
        }
    }
}
```
```json Params Schema
{
    "title": "Signin Response Params Schema",
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "/static/schemas/comms/auth/signin/signin-response.json",
    "type": "object",
    "required": [
        "signature",
        "encrypt-challenge"
    ],
    "properties": {
        "signature": {
            "type": "string",
            "format": "base64"
        },
        "decrypted": {
            "type": "string",
            "minLength": 128,
            "maxLength": 128
        }
    }
}
```
</CodeGroup>

#### Parameters

<ParamField body="signature" type="string" required>
    Signature of `sign-challenge` calculated using user private `sk`.
</ParamField>
<ParamField body="decrypted" type="string" required>
    Decrypted contents of `encrypt-challenge` using user private `ek`.
</ParamField>



### 4. `signin-complete` *(Server → Client)*

If the signature is valid, the server returns the authenticated user profile and session metadata.

<CodeGroup>
```json Example
{
    "target": "auth",
    "data": {
        "action": "signin-complete",
        "params": {
            "user": {},
        }
    }
}
```
```json Params Schema
{
    "title": "Signin Complete Params Schema",
    "$schema": "https://json-schema.org/draft/2020-12/schema",
    "$id": "/static/schemas/comms/auth/signin/signin-complete.json",
    "type": "object",
    "required": [
        "status",
        "user"
    ],
    "properties": {
        "user": {
            "type": "object",
            "$ref": "/static/schemas/user/private-user.json"
        }
    }
}
```
</CodeGroup>

#### Parameters

<ParamField body="user" type="object" required>
    [Private User Object](/protocol/definitions/users/data.mdx#private-user-structure).
</ParamField>

---

<Danger>If at any point the signin fails, the server will return one of the following [Error Messages](/protocol/targets/error.mdx)</Danger>

| Message             | Description                                                             | Possible Causes                                                                  |
|---------------------|-------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| `invalid-key`       | The provided public key is malformed or unsupported.                    | Public key does not match expected format (e.g. not Ed25519 / invalid base64).   |
| `already-started`   | A sign-in session has already been initiated for this key.              | Calling `signin-start` again before completing the previous session.             |
| `not-started`       | No active sign-in session found for this key.                           | Calling `signin-challenge`, `signin-response`, or `signin-complete` prematurely. |
| `challenge-failed`  | One or more cryptographic challenges failed verification.               | Incorrect signing/encryption of challenge payloads.                              |
| `expired`           | The sign-in session has expired and is no longer valid.                 | Delay between steps exceeded server timeout.                                     |

---

<Note>Notes</Note>

- No session tokens are used — the connection is tied to the successful authentication over the WebSocket.
- Each signin must be completed in order: no skipping steps.
- A challenge expires after a short timeout; clients must retry with a new `signin-start` if it expires.
- Each connection may only have **one** active signin attempt at any given time.