---
title: User Identity
description: How users are identified and authenticated in the protocol.
---

import {SchemaExample} from "@site/src/components/SchemaExample";
import {ParamsList} from "@site/src/components/ParamsList";
import {Param} from "@site/src/components/Param";

# User Identity

This page outlines how users are uniquely identified in the protocol, and the reasoning behind using cryptographic
keys instead of traditional identifiers such as usernames or passwords.

Required knowledge:
- [Keys](/docs/protocol/definitions/crypto/keys.mdx)

## Identity Through Public Keys

To simplify user identity management, the user's [`sk`](/docs/protocol/definitions/crypto/keys.mdx#signing-key)
can be used as a shorthand identifier for the user within the current server context.

This does not comply with MLS, and as such is not used for MLS purposes, but is used for other protocol features.

In order to allow for compliance with MLS, the [`UserPackage`](#user-package) is used to represent the user in MLS
contexts, which contains the user's public keys and other metadata.

---

## Why Not Use Emails or Usernames?

This system deliberately avoids email-password or username-password logins for several reasons:

### Decentralization

- There's no need for a central authority to issue or verify accounts.
- Users can generate their identity locally, even offline.

### Security

- Passwords are inherently weak — they can be reused, guessed, or leaked.
- Public-key auth ensures only the holder of the private key can act as a user.

### Privacy

- No personal information is required to create or use an identity.
- Even the server does not need to know who you "are" — just that you control your keys.

---

## Key Ownership = Identity

In this system, **identity is not what you know (a password)** — it’s **what you own** (a keypair).

If a user loses their private keys, they lose access to their identity and must start fresh. For this reason, secure client-side storage and optional key backup/export features are essential at the UI level.

---

## User Package

The `UserPackage` is a structure that contains the user's public keys and other metadata, used in MLS contexts.
<SchemaExample path="/definitions/crypto/user-package.json">
```json Example
{
    "keypair": {
        "sk": "BASE64/HEX_STRING",
        "ek": "BASE64/HEX_STRING"
    },
    "profile": {  ...  },
    "origin": {  ...  },
    "sig": "BASE64/HEX_STRING"
}
```
</SchemaExample>

<ParamsList>
    <a href="/docs/protocol/definitions/crypto/keys">
        <Param name="keypair" type="object" required>
            The user's public keys.
        </Param>
    </a>
    <a href="/docs/protocol/definitions/user/data">
        <Param name="profile" type="object" required>
            The user's profile information.
        </Param>
    </a>
    <a href="/docs/protocol/definitions/origin">
        <Param name="origin" type="object" required>
            The origin server details for the user.
        </Param>
    </a>
    <Param name="sig" type="string" required>
        The signature of the package, signed with the user's signing key.
    </Param>
</ParamsList>


## Summary

| Traditional Identity     | Cryptographic Identity        |
|--------------------------|-------------------------------|
| Email + Password         | Signing + Encryption Keys     |
| Centralized login server | Trustless, key-based auth     |
| Can be faked or stolen   | Tied to possession of keys    |
| Leaks personal info      | Preserves privacy             |

The result is a more secure, decentralized, and privacy-preserving identity model that aligns with the protocol’s design goals.

